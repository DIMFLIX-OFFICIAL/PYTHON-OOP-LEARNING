# Staticmethod и Classmethod

**@staticmethod** - это декоратор для методов, которые принадлежат классу, а не экземпляру класса. Их можно вызвать в самом классе, без необходимости создавать экземпляр класса.\
Грубо говоря сам метод ничего не знает о классе, но находится в нем. Так-же стоит отметить, что аргумент **self** передавать не нужно.

Для чего же он такой чудной нужен? - спросите Вы. На это я могу вам лишь сказать о том, что данное решение помогает в достижении инкапсуляции в классе, т.к он не знает о состоянии текущего экземпляра. Так-же такое решение повышает читабельность, а так-же привносит возможность импортировать этот метод прямо из классов.

```python
class MyClass: 
    @staticmethod 
    def my_static_method(): 
        print("Это статический метод")
        
MyClass.my_static_method() # >>> "Это статический метод"
```

Как вы и могли заметить, в данном примере не создается **экземпляр** класса, но мы имеем доступ к статическому методу.



**@classmethod** - с ним ситуация инвертированная.  Это метод, который получает класс в качестве неявного первого аргумента, точно так же, как обычный метод экземпляра получает экземпляр, следовательно мы можем использовать класс и его свойства внутри этого метода, а не конкретного экземпляра.

Если по простому, то это обычный метод класса, имеющий доступ ко всем атрибутам класса, через который он был вызван. Соответственно **classmethod** – это метод, который привязан к классу, а не к экземпляру класса.

```python
class MyClass:
    count = 0

    def __init__(self):
        MyClass.count += 1

    @classmethod
    def get_count(cls):
        return cls.count

print(MyClass.get_count())  # >>> 0

obj1 = MyClass()
print(MyClass.get_count())  # >>> 1

obj2 = MyClass()
print(MyClass.get_count())  # >>> 2
```
